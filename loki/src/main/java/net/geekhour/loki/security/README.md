# JWT

JWT分为三部分：Header、Payload、Signature。

## Header
Header部分是一个JSON对象，描述JWT的元数据，通常是下面的样子。
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。

然后，将上面的JSON对象使用 Base64URL 算法转成字符串。

## Payload
Payload部分也是一个JSON对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。
```json
{
  "iss": "John Wu JWT", // 签发者
  "iat": 1441593502, // 签发时间
  "exp": 1441594722, // 过期时间
  "aud": "www.example.com", // 接收方
  "sub": "admin", // 面向的用户
  "nbf": 1441594722, // 生效时间
  "jti": "id123456" // 编号
}

```

iss: Issuer，发行者
exp: Expiration Time，过期时间
sub: Subject，主题
aud: Audience，观众
nbf: Not Before，生效时间
iat: Issued At，发行时间
jti: JWT ID，编号

除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
私有字段不会与其他人发生冲突，因此可以放心使用。但是，不要在JWT的payload中放置任何机密信息，因为该部分可以由客户端解密。

## Signature
Signature部分是对前两部分的签名，防止数据篡改。
使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。
```java
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
也就是说，两个Base64字符串用句点（.）连接在一起，然后再用 Header 里面指定的算法进行加密。

## 生成方法
1. 首先，需要一个服务端私钥（secret），这个密钥只有服务器才知道，不能泄露给用户。
2. 然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。
```java
  public void jwt(){
    JwtBuilder jwtBuilder = Jwts.builder();
    String jwtToken = jwtBuilder.setHeaderParam("alg", "HS256")
            .setHeaderParam("typ", "JWT")
            .setSubject("hela")
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
            .signWith(SignatureAlgorithm.HS256, "hela")
            .compact();
  }
```
3. 最后，将上面的三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。
```java
base64UrlEncode(header) + "." +
base64UrlEncode(payload) + "." +
base64UrlEncode(signature)
```
4. 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。
5. 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。

## 验证方法
1. 首先，检查这个 JWT 是否合法，具体方法是检查签名是否正确。只要有一点被篡改，就会导致签名错误。
2. 其次，检查 JWT 是否过期。这一点可以在 Payload 里面设置一个 exp 字段。
3. 如果过期了，就拒绝访问，有的实现还会提示用户，Token过期了。
4. 如果没有过期，就允许用户访问。但是，这样每次用户访问受保护的资源，服务器都要解密 JWT，这会降低运行效率。一个更好的方法是，JWT 的本身包含了认证信息，服务器根本不用查询数据库，就可以直接返回所需要的信息。这就是为什么 JWT 经常用于单点登录（Single Sign On）场景。
5. 如果你担心 JWT 会增大网络传输的大小，可以使用压缩算法再行压缩。
6. 如果你担心 JWT 会被盗用，可以使用加密算法再行加密。
7. 如果你担心 JWT 会被篡改，可以使用前面介绍的签名算法进行签名。
8. 如果你担心 JWT 会被篡改，还可以在生成签名的时候，加上一些额外的信息，例如用户的 IP 地址和登录时的时间。这样一来，如果有人盗用这个 JWT，你会发现有地方不对劲。
9. 如果你担心 JWT 会被盗用，还可以使用短期 JWT，也就是说，JWT 的有效期一般设置得比较短，用户只要一段时间不登录网站，JWT 就会失效。这样可以有效降低盗用的危险性。
10. 如果你担心 JWT 会被盗用，还可以使用 JWT Blacklist，也就是说，每次用户退出登录时，将相应的 JWT 加入黑名单。下次该 JWT 再通过验证时，就会被拒绝。这种方法的缺点是，你必须在服务器端保存所有 JWT 的黑名单，才能判断是否有效。另一种方法是，JWT 的有效期不要设置得太长，然后定期清理过期的 JWT。这种方法的缺点是，服务器端必须有一个定时清理的任务。
11. 如果你担心 JWT 会被盗用，还可以使用 JWT Refresh，也就是说，JWT 的有效期设置得比较短，用户每次使用 JWT 请求数据时，服务器都会返回一个新的 JWT。这种方法的缺点是，服务器必须记录下每个 JWT 的生成时间，才能确定何时到期。另一种方法是，每次生成 JWT 的时候，将"签发时间"（Issued At）放进去，然后设置一个"刷新间隔"。每次用户使用 JWT 请求数据时，服务器都会检查当前时间减去"签发时间"，是否大于"刷新间隔"。如果大于，就返回一个新的 JWT，否则返回原来的 JWT。这种方法的缺点是，服务器必须记录下每个 JWT 的生成时间，才能确定何时到期。
12. 如果你担心 JWT 会被盗用，还可以使用 JWT One-time Token，也就是说，JWT 只能使用一次，不能重复使用。这种方法的缺点是，服务器必须记录下每个 JWT 是否已经被使用过，从而拒绝重复使用。
13. 如果你担心 JWT 会被盗用，还可以使用 JWT + Session，也就是说，JWT 只是用来认证，服务器还是使用 Session 保存用户的数据。这种方法的缺点是，服务器必须记录下每个 JWT 是否已经被使用过，从而拒绝重复使用。
14. 如果你担心 JWT 会被盗用，还可以使用 JWT + CSRF Token，也就是说，JWT 只是用来认证，服务器还是使用 CSRF Token 防止跨站攻击。这种方法的缺点是，服务器必须记录下每个 JWT 是否已经被使用过，从而拒绝重复使用。
15. 如果你担心 JWT 会被盗用，还可以使用 JWT + 双重Cookie，也就是说，JWT 只是用来认证，服务器还是使用双重 Cookie 防止跨站攻击。这种方法的缺点是，服务器必须记录下每个 JWT 是否已经被使用过，从而拒绝重复使用。

## JWT的优缺点
### 优点
1. JWT 的最大优点就是服务器不保存任何状态，服务器的负载也比较小。由于 JWT 包含了认证信息，因此服务器不保存任何会话数据，这是无状态（stateless）协议，而 Session 基于 Cookie 的，所以是有状态（stateful）协议。无状态协议使得 JWT 可以在多个服务之间共享，也可以作为跨域登录的一种解决方案。
2. JWT 的另一个优点是，由于生成 JWT 的算法是可扩展的，因此，你可以自己实现算法，定制自己的 JWT。例如，可以将用户权限信息加密，存储在 JWT 里面，这样就可以减少查询数据库的操作。
3. JWT 还有一个优点，就是它本身包含认证信息，也就是说，用户一旦拿到 JWT，就可以自己解密得到里面的信息。因此，你可以确保 JWT 的合法性，只要确保私钥不泄露就行了。这种特点使得 JWT 适用于单点登录场景（Single Sign On）。
4. JWT 的最后一个优点是，它的标准化使得它更容易被开发者接受，因为它已经成为一种事实上的标准，大家都在用了。

### 缺点
1. JWT 的最大缺点是，由于服务器不保存会话状态，因此无法在使用过程中废止某个令牌（或者说，一旦签发了 JWT，就无法做到废止，除非把过期时间设置得很短）。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
2. JWT 一旦签发，在有效期内将会始终有效，无法在中途废止。因此，JWT 不适合用作某些场合下的会话管理。假设某个用户的 JWT 泄露了，为了减少盗用的危险，你只能等到它过期。上面这种情况，可以通过短一点的过期时间来缓解。但是，一旦你设置得太短，可能会造成用户体验不佳。

## JWT的使用场景
1. 授权（Authorization）：这是使用 JWT 的最常见场景。一旦用户登录，后端服务器返回一个 JWT，以后用户与后端通信时，都要带上这个 JWT。服务器只要验证 JWT 的合法性，就可以知道用户是否登录，以及其拥有的权限。
2. 信息交换（Information Exchange）：JSON Web Token 是在网络上以开放标准[RFC 7519](https://tools.ietf.org/html/rfc7519)传输信息的一种基于 JSON 的标准。JWT 可以被用来传输任何形式的信息，因为它是使用数字签名的，所以是安全的。
3. 单点登录（Single Sign On）：这是使用 JWT 的另一个常见场景。这种情况下，用户在登录一个应用程序后，可以访问另一个应用程序，而无需再次进行身份验证。这是因为第一个应用程序在登录用户时，会颁发一个 JWT，保存在浏览器的 Cookie 里面。之后，另一个应用程序可以读取这个 JWT，从而知道用户已经登录过了。这种方式有一个好处，就是用户只要一次登录，就可以访问所有相互信任的应用程序。
4. 无状态（Stateless）：服务器不保存任何状态，客户端负责把所有信息都保存在本地。这种方式使得服务器的负载比较轻，也比较容易扩展。但是，这种方式也有一个缺点，就是服务器无法踢掉一个用户。如果想踢掉一个用户，只能改变密钥，这样就会造成所有用户都失效。
5. 无需 CSRF（Cross-site request forgery）防护：JWT 本身就包含了用户信息，因此服务器无需再存储用户相关的任何信息。这种方式使得 JWT 非常适合使用在跨域环境下，比如使用 JWT 的一个常见场景是，使用一个单独的域名来处理所有 API 请求，而使用传统的 session 则需要在多个域名之间共享 session。
6. 传统 Cookie 的一些缺点：Cookie 是一种服务器留在用户计算机上的小文件，每次浏览器向服务器发出请求，就会把这个文件发送给服务器。服务器可以从 Cookie 中读取用户的信息。Cookie 最大的缺点是，它的所有信息都是以明文传输，如果攻击者截获了 Cookie，就可以取得所有的用户信息。虽然可以使用加密技术，让 Cookie 加密，但是这样会增加服务器的处理负担。JWT 可以在服务器端直接解密，因此运算量相对较少，可以很容易地使用 HTTPS 协议传输。
7. 传统 Session 的一些缺点：Session 是另一种记录服务器与客户端会话状态的机制。Session 保存在服务器端，客户端只能拿到一个 ID，指向服务器端的 Session。服务器端根据这个 ID，就能找到对应的 Session。Session 最大的问题就是保存在服务器端，如果服务器挂了，所有的会话状态就消失了。为了解决这个问题，可以把 Session 保存在数据库或者其他外部存储上面，但是这样会引起另一个问题，就是每次读取 Session 都需要查询一次数据库。这种情况下，JWT 就表现得很优雅，因为它不需要查询数据库，而且即使服务器挂了，用户的会话状态也不会丢失。
8. 传统 Session 的另一个缺点是，它不适合分布式应用。假设我们有两台服务器，用户的会话状态保存在服务器 A，但是用户的请求被负载均衡器转发到了服务器 B。这时，用户在服务器 A 的会话状态对服务器 B 是不可见的。为了解决这个问题，可以把 Session 放到一个统一的地方，比如数据库或者缓存。这样就增加了服务器的负载，而且对网络的依赖性比较高。JWT 就不存在这个问题，因为它的会话状态是保存在客户端的。

